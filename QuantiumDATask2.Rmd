---
title: "QuantiumDATask2"
author: "Santosh Reddy Edulapalle"
date: "2023-03-27"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load required libraries and datasets

```{r 0. Load libraries, include = FALSE}
library(data.table)
library(ggplot2)
library(tidyr)
```

```{r 1. Read in data from previous module}
filePath <- "/Users/santosh/Documents/QuantiumDA/quantiumDA/"
df <- fread(paste0(filePath,"QVI_data.csv"))
#### Set themes for plots
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5))
```

```{r}
head(df)
```

## Select control stores
The client has selected store numbers 77, 86 and 88 as trial stores and want
control stores to be established stores that are operational for the entire
observation period.
We would want to match trial stores to control stores that are similar to the trial
store prior to the trial period of Feb 2019 in terms of :
- Monthly overall sales revenue
- Monthly number of customers
- Monthly number of transactions per customer
Let's first create the metrics of interest and filter to stores that are present
throughout the pre-trial period.


```{r Select control stores}
#### Calculate these measures over time for each store
#### Add a new month ID column in the data with the format yyyymm.

df <- df[, YEARMONTH := (format(as.Date(df$DATE,format = "%Y/%m/%d"),paste("%Y","%m",sep = ""))) ]

#### Next, we define the measure calculations to use during the analysis.

# Over to you! For each store and month calculate total sales, number of customers,transactions per customer, chips per customer and the average price per unit.
## Hint: you can use uniqueN() to count distinct values in a column
measureOverTime <- df[, .(totSales = sum(TOT_SALES), 
                          nCustomers = uniqueN(LYLTY_CARD_NBR), 
                          nTxnPerCust = length(unique(TXN_ID))/uniqueN(LYLTY_CARD_NBR), 
                          nChipsPerTxn = sum(PROD_QTY)/length(unique(TXN_ID)), 
                          avgPricePerUnit = (sum(TOT_SALES)/sum(PROD_QTY))
                            ), 
                      by = .(STORE_NBR,YEARMONTH) ][order(STORE_NBR,YEARMONTH)]
#### Filter to the pre-trial period and stores with full observation periods
storesWithFullObs <- unique(measureOverTime[, .N, STORE_NBR][N == 12, STORE_NBR])
preTrialMeasures <- measureOverTime[YEARMONTH < 201902 & STORE_NBR %in% storesWithFullObs, ]
```


Now we need to work out a way of ranking how similar each potential control store
is to the trial store. We can calculate how correlated the performance of each
store is to the trial store.
Let's write a function for this so that we don't have to calculate this for each
trial store and control store pair.

```{r Create function to calculate correlation}
#### Create a function to calculate correlation for a measure, looping through each control store.
#### Let's define inputTable as a metric table with potential comparison stores, metricCol as the store metric used to calculate correlation on, and storeComparison as the store number of the trial store.

calculateCorrelation <- function(inputTable, metricCol, storeComparison) {
  calcCorrTable <- data.table(Store1 = numeric(), Store2 = numeric(), corr_measure = numeric())
  
  storeNumbers <- unique(inputTable[, STORE_NBR])
  
  for (i in storeNumbers) {
    if (i != storeComparison) {
  
      comparisonTable <- inputTable[STORE_NBR == storeComparison, ]
      controlTable <- inputTable[STORE_NBR == i, ]
      
      correlation <- cor(comparisonTable[[metricCol]], controlTable[[metricCol]])
      
      calculatedMeasure <- data.table("Store1" = storeComparison, "Store2" = i, "corr_measure" = correlation)
      
      calcCorrTable <- rbind(calcCorrTable, calculatedMeasure)
  
    }
  }
  
  return(calcCorrTable)
}


```



Apart from correlation, we can also calculate a standardised metric based on the
absolute difference between the trial store's performance and each control store's
performance.
Let's write a function for this.

```{r Create function to calculate magnitude distance}
#### Create a function to calculate a standardised magnitude distance for a measure,
#### looping through each control store

calculateMagnitudeDistance <- function(inputTable, metricCol, storeComparison) {
calcDistTable = data.table(Store1 = numeric(), Store2 = numeric(), YEARMONTH = numeric(), measure = numeric())
storeNumbers <- unique(inputTable[, STORE_NBR])

 for (i in storeNumbers) {
   if (i != storeComparison) {
 calculatedMeasure = data.table("Store1" = storeComparison,
                                "Store2" = i,
                                "YEARMONTH" = inputTable[STORE_NBR == storeComparison, YEARMONTH],
                                "measure" = abs(inputTable[STORE_NBR == storeComparison, eval(metricCol)] - inputTable[STORE_NBR == i, 
                                                                                                                      eval(metricCol)]))
 calcDistTable <- rbind(calcDistTable, calculatedMeasure)
 }
}
#### Standardise the magnitude distance so that the measure ranges from 0 to 1

 minMaxDist <- calcDistTable[, .(minDist = min(measure), maxDist = max(measure)), by = c("Store1", "YEARMONTH")]
 distTable <- merge(calcDistTable, minMaxDist, by = c("Store1", "YEARMONTH"))
 distTable[, magnitudeMeasure := 1 - (measure - minDist)/(maxDist - minDist)]

 finalDistTable <- distTable[, .(mag_measure = mean(magnitudeMeasure)), by = .(Store1, Store2)]
 return(finalDistTable)
}
```


Now let's use the functions to find the control stores! We'll select control stores
based on how similar monthly total sales in dollar amounts and monthly number of
customers are to the trial stores. So we will need to use our functions to get four
scores, two for each of total sales and total customers.

```{r Use functions to calculate metrics}
#### Over to you! Use the function you created to calculate correlations against store 77 using total sales and number of customers.
#### Hint: Refer back to the input names of the functions we created.
trial_store <- 77
corr_nSales <- calculateCorrelation(preTrialMeasures, quote(totSales), trial_store)
corr_nCustomers <- calculateCorrelation(preTrialMeasures, quote(nCustomers), trial_store)

#### Then, use the functions for calculating magnitude.
magnitude_nSales <- calculateMagnitudeDistance(preTrialMeasures, quote(totSales),trial_store)
magnitude_nCustomers <- calculateMagnitudeDistance(preTrialMeasures, quote(nCustomers), trial_store)
```


We'll need to combine the all the scores calculated using our function to create a
composite score to rank on.
Let's take a simple average of the correlation and magnitude scores for each
driver. Note that if we consider it more important for the trend of the drivers to
be similar, we can increase the weight of the correlation score (a simple average
gives a weight of 0.5 to the corr_weight) or if we consider the absolute size of
the drivers to be more important, we can lower the weight of the correlation score.
```{r}
#### Create a combined score composed of correlation and magnitude, by first merging the correlations table with the magnitude table.
#### Hint: A simple average on the scores would be 0.5 * corr_measure + 0.5 * mag_measure
corr_weight <- 0.5
score_nSales <- merge(corr_nSales, magnitude_nSales, by = c("Store1","Store2"))[, scoreNSales := corr_weight * corr_nSales[, corr_measure] 
                                                                  + corr_weight * magnitude_nSales[, mag_measure]]
score_nCustomers <- merge(corr_nCustomers, magnitude_nCustomers, by = c("Store1","Store2"))[, scoreNCust := corr_weight * corr_nSales[, corr_measure] + corr_weight * magnitude_nSales[, mag_measure]]
```


Now we have a score for each of total number of sales and number of customers.
Let's combine the two via a simple average.
```{r}
#### Combine scores across the drivers by first merging our sales scores and customer scores into a single table
score_Control <- merge(score_nSales, score_nCustomers, by = c("Store1","Store2") )
score_Control[, finalControlScore := scoreNSales * 0.5 + scoreNCust * 0.5]
```


The store with the highest score is then selected as the control store since it is
most similar to the trial store.
```{r}
#### Select control stores based on the highest matching store (closest to 1 but not the store itself, i.e. the second ranked highest store)
#### Select the most appropriate control store for trial store 77 by finding the store with the highest final score.
control_store <- score_Control[finalControlScore == max(finalControlScore),Store2]
control_store
```

Now that we have found a control store, let's check visually if the drivers are
indeed similar in the period before the trial.
We'll look at total sales first.
```{r}
#### Visual checks on trends based on the drivers
measureOverTimeSales <- measureOverTime
# Convert YEARMONTH to numeric
measureOverTimeSales$YEARMONTH <- as.numeric(measureOverTimeSales$YEARMONTH)

pastSales <- measureOverTimeSales[, Store_type := ifelse(STORE_NBR == trial_store, "Trial", ifelse(STORE_NBR == control_store, "Control", "Other stores"))][, totSales := mean(totSales), by = c("YEARMONTH","Store_type") ][, TransactionMonth := as.Date(paste(YEARMONTH %/% 100, YEARMONTH %% 100, 1, sep = "-"), "%Y-%m-%d")][YEARMONTH < 201903 , ]

ggplot(pastSales, aes(TransactionMonth, totSales, color = Store_type)) +
 geom_line() +
 labs(x = "Month of operation", y = "Total sales", title = "Total sales by month")
```


Next, number of customers.
```{r}
#### Conduct visual checks on customer count trends by comparing the trial store to the control store and other stores.
#### Hint: Look at the previous plot.
measureOverTimeCusts <- measureOverTime
# Convert YEARMONTH to numeric
measureOverTimeCusts$YEARMONTH <- as.numeric(measureOverTimeCusts$YEARMONTH)

pastCustomers <- measureOverTimeCusts[, Store_type := ifelse(STORE_NBR == trial_store, "Trial", ifelse(STORE_NBR == control_store, "Control", "Other stores"))][, nCustomers := mean(nCustomers), by = c("YEARMONTH","Store_type") ][, TransactionMonth := as.Date(paste(YEARMONTH %/% 100, YEARMONTH %% 100, 1, sep = "-"), "%Y-%m-%d")][YEARMONTH < 201903 , ]


ggplot(pastCustomers, aes(TransactionMonth, nCustomers, color = Store_type)) +
 geom_line() +
 labs(x = "Month of operation", y = "Total Customers", title = "Total Customers by month" )
```

## Assessment of trial

The trial period goes from the start of February 2019 to April 2019. We now want to
see if there has been an uplift in overall chip sales.
We'll start with scaling the control store's sales to a level similar to control
for any differences between the two stores outside of the trial period.

```{r Comparison of results during trial}
#### Scale pre-trial control sales to match pre-trial trial store sales
scalingFactorForControlSales <- preTrialMeasures[STORE_NBR == trial_store & YEARMONTH < 201902, 
                                                 sum(totSales)]/preTrialMeasures[STORE_NBR == control_store & YEARMONTH < 201902, sum(totSales)]
#### Apply the scaling factor
measureOverTimeSales <- measureOverTime
scaledControlSales <- measureOverTimeSales[STORE_NBR == control_store, ][ ,controlSales := totSales * scalingFactorForControlSales]
```


Now that we have comparable sales figures for the control store, we can calculate
the percentage difference between the scaled control sales and the trial store's
sales during the trial period.
```{r}
#### Over to you! Calculate the percentage difference between scaled control sales and trial sales
percentageDiff <- merge(, , by = )[, percentageDiff := ]
```




